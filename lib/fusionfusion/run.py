#! /usr/bin/env python

import sys, os, argparse, subprocess, yaml
import parseJunctionInfo
import filterJunctionInfo
import annotationFunction
import utils

def cluster_filter_junction(inputFilePath, outputFilePrefix, Params):

    parseJunctionInfo.clusterJuncInfo(inputFilePath,
                                      outputFilePrefix + ".chimeric.clustered.txt")

    filterJunctionInfo.filterCoverRegion(outputFilePrefix + ".chimeric.clustered.txt",
                                         outputFilePrefix + ".chimeric.clustered.filt1.txt", Params)
    
    filterJunctionInfo.extractSplicingPattern(outputFilePrefix + ".chimeric.clustered.filt1.txt", 
                                              outputFilePrefix + ".chimeric.clustered.splicing.txt", Params)

    ############
    filterJunctionInfo.makeJucSeqPairFa(outputFilePrefix + ".chimeric.clustered.splicing.txt",
                                        outputFilePrefix + ".chimeric.clustered.splicing.contig.fa", Params)

    # alignment of contigs generated by manual assembly
    blat_path = Params["blat_path"]
    blat_options = Params["blat_option"].split(' ')
    reference_genome = Params["reference_genome"]

    FNULL = open(os.devnull, 'w')
    fRet = subprocess.call([blat_path] + blat_options + [reference_genome, 
                            outputFilePrefix + ".chimeric.clustered.splicing.contig.fa",
                            outputFilePrefix + ".chimeric.clustered.splicing.contig.psl"], stdout = FNULL, stderr = subprocess.STDOUT)

    FNULL.close()
    if fRet != 0:
        print >> sys.stderr, "blat error, error code: " + str(fRet)
        sys.exit()


    filterJunctionInfo.checkMatching(outputFilePrefix + ".chimeric.clustered.splicing.contig.psl",
                                     outputFilePrefix + ".chimeric.clustered.splicing.contig.check.txt", Params)

    filterJunctionInfo.filterContigCheck(outputFilePrefix + ".chimeric.clustered.splicing.txt",
                                         outputFilePrefix + ".chimeric.clustered.filt2.txt",
                                         outputFilePrefix + ".chimeric.clustered.splicing.contig.check.txt", Params)

    annotationFunction.filterAndAnnotation(outputFilePrefix + ".chimeric.clustered.filt2.txt",
                                           outputFilePrefix + ".fusion.result.txt", Params)

def main(args):

    starBamFile = args.star
    ms2BamFile = args.ms2
    output_dir = args.out

    try:
        with open(args.param, 'r') as fIN:
            paramConf = yaml.load(fIN)
    except yaml.YAMLError, exc:
        print "Error in sample information file:", exc


    ####################
    # make direcotry
    utils.make_directory(output_dir)
    ####################

    ####################
    # parsing chimeric reads from bam files
    if starBamFile is not None:

        parseJunctionInfo.parseJuncInfo_STAR(starBamFile, output_dir + "/star.chimeric.tmp.txt", paramConf)

        hOUT = open(output_dir + "/star.chimeric.txt", "w")
        subprocess.call(["sort", "-k1,1", "-k2,2n", "-k4,4", "-k5,5n", output_dir + "/star.chimeric.tmp.txt"], stdout = hOUT)
        hOUT.close()

        cluster_filter_junction(output_dir + "/star.chimeric.txt", output_dir + "/star", paramConf)


    if ms2BamFile is not None:
   
        """ 
        parseJunctionInfo.extractFusionReads_ms2(ms2BamFile, output_dir + "/ms2.chimeric.tmp.sam", paramConf)

        hOUT = open(output_dir + "/ms2.chimeric.sam", "w")
        subprocess.call(["sort", "-k1", output_dir + "/ms2.chimeric.tmp.sam"], stdout = hOUT)
        hOUT.close()

        parseJunctionInfo.parseJuncInfo_ms2(output_dir + "/ms2.chimeric.sam", output_dir + "/ms2.chimeric.tmp.txt", paramConf) 
        """

        hOUT = open(output_dir + "/ms2.chimeric.txt", "w")
        subprocess.call(["sort", "-k1,1", "-k2,2n", "-k4,4", "-k5,5n", output_dir + "/ms2.chimeric.tmp.txt"], stdout = hOUT)
        hOUT.close()

        cluster_filter_junction(output_dir + "/ms2.chimeric.txt", output_dir + "/ms2", paramConf)


